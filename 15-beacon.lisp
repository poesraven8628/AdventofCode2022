(ql:quickload "str")

(defun get-all-input (input)
  (with-open-file (stream input)
    (loop for line = (read-line stream nil)
          while line
          collect line)))

(defun parse-input (input &aux inp ret)
  (dolist (e input (reverse ret))
    (setf inp (str:words e))
    (push (list (parse-integer (nth 1 (str:split "=" (nth 2 inp))) :junk-allowed t)
		(parse-integer (nth 1 (str:split "=" (nth 3 inp))) :junk-allowed t)
		(parse-integer (nth 1 (str:split "=" (nth 8 inp))) :junk-allowed t)
		(parse-integer (nth 1 (str:split "=" (nth 9 inp))) :junk-allowed t))
	  ret)))

(defun mdist (x1 y1 x2 y2)
  (let ((x 0)
	(y 0))
    (setf x (abs (- x2 x1)))
    (setf y (abs (- y2 y1)))
    (+ x y)))

(defun proc-sensor (lst &aux ret)
  (dolist (e lst (reverse ret))
    (push (list (nth 0 e) (nth 1 e)
		(mdist (nth 0 e) (nth 1 e)
		       (nth 2 e) (nth 3 e)))
	  ret)))

(defun x-range (lst)
  (let ((low-x (first (first lst)))
	(high-x (first (second lst))))
    (dolist (e lst (list (- low-x 1) (+ high-x 1)))
      (if (< (- (nth 0 e) (nth 2 e)) low-x)
	  (setf low-x (- (nth 0 e) (nth 2 e))))
      (if (> (+ (nth 0 e) (nth 2 e)) high-x)
	  (setf high-x (+ (nth 0 e) (nth 2 e)))))))

(defun sensor-interval (y sensor)
  (let ((range (- (nth 2 sensor) (abs (- (nth 1 sensor) y)))))
    (when (>= range 0)
      (list (- (nth 0 sensor) range) (+ (nth 0 sensor) range)))))

(defun covered-intervals (y lst)
  (let ((covered nil))
    (dolist (e lst covered)
      (push (sensor-interval y e) covered))))

(defun check-covered (y input)
  (do* ((intervals (sort (remove-if #'null
				    (covered-intervals y (proc-sensor (parse-input (get-all-input input)))))
			 #'(lambda (a b) (< (first a) (first b)))) (rest intervals))
	(covered 0)
	(int (first intervals) (first intervals))
	(x (first int)))
       ((null int) covered)
    (when (and (>= x (first int))
	       (<= x (second int)))
      (incf covered (- (second int) x)))
    (when (< x (second int))
      (setf x (second int)))))

(defun find-beacon (end-x end-y input)
  (do* ((y 0 (+ y 1))
	(intervals (sort (remove-if #'null
				    (covered-intervals y (proc-sensor (parse-input (get-all-input input)))))
			 #'(lambda (a b) (< (first a) (first b))))
		   (sort (remove-if #'null
				    (covered-intervals y (proc-sensor (parse-input (get-all-input input)))))
			 #'(lambda (a b) (< (first a) (first b))))))
       ((> y end-y))
    (do* ((ints intervals (rest ints))
	  (int (first ints) (first ints))
	  (x 0))
	 ((null int))
      (when (< x (first int))
	(return-from find-beacon (list x y)))
      (when (< x (second int))
	(setf x (+ 1 (second int))))
      (when (> x end-x)
	(return)))))

(defun calc-freq (lst)
  (let ((x (first lst))
	(y (second lst)))
    (+ (* x 4000000) y)))

(check-covered 2000000 "input.txt")
(calc-freq (find-beacon 4000000 4000000 "input.txt"))


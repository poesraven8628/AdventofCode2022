(ql:quickload "str")

(defun get-all-input (input)
  (with-open-file (stream input)
    (loop for line = (read-line stream nil)
          while line
          collect line)))

(defun parse-input (input &aux inp ret)
  (dolist (e input (reverse ret))
    (setf inp (str:split "," e))
    (push (list (parse-integer (nth 0 inp))
		(parse-integer (nth 1 inp))
		(parse-integer (nth 2 inp))) ret)))

(defun get-size (input &aux (x1 100) (y1 100) (z1 100) (x2 -1) (y2 -1) (z2 -1))
  (dolist (p input (list (list (- x1 2) (- y1 2) (- z1 2))
			 (list (+ x2 2) (+ y2 2) (+ z2 2))))
    (if (< (first p) x1) (setf x1 (first p)))
    (if (> (first p) x2) (setf x2 (first p)))
    (if (< (second p) y1) (setf y1 (second p)))
    (if (> (second p) y2) (setf y2 (second p)))
    (if (< (third p) z1) (setf z1 (third p)))
    (if (> (third p) z2) (setf z2 (third p)))))

(defun make-map (size &aux x1 x2 y1 y2 z1 z2)
  (setf x1 (first (first size)))
  (setf y1 (second (first size)))
  (setf z1 (third (first size)))
  (setf x2 (first (second size)))
  (setf y2 (second (second size)))
  (setf z2 (third (second size)))
  (make-array (list (- x2 x1) (- y2 y1) (- z2 z1)) :initial-element nil))

(defun fill-map (map points ox oy oz)
  (dolist (p points map)
    (setf (aref map (- (first p) ox)
		(- (second p) oy)
		(- (third p) oz)) t)))

(defun setup (input)
  (let* ((points (parse-input (get-all-input input)))
	 (size (get-size points))
	 (map (make-map size))
	 (ox (first (first size)))
	 (oy (second (first size)))
	 (oz (third (first size))))
    (fill-map map points ox oy oz)))

(defun check-sides (x y z map)
  (let ((count 0)
	(mx (- (first (array-dimensions map)) 1))
	(my (- (second (array-dimensions map)) 1))
	(mz (- (third (array-dimensions map)) 1)))
    (unless (equal (aref map x y z) t)
      (if (not (zerop x))
	  (if (equal (aref map (- x 1) y z) t) (incf count)))
      (if (not (equal x mx))
	  (if (equal (aref map (+ x 1) y z) t) (incf count)))
      (if (not (zerop y))
	  (if (equal (aref map x (- y 1) z) t) (incf count)))
      (if (not (equal y my))
	  (if (equal (aref map x (+ y 1) z) t) (incf count)))
      (if (not (zerop z))
	  (if (equal (aref map x y (- z 1)) t) (incf count)))
      (if (not (equal z mz))
	  (if (equal (aref map x y (+ z 1)) t) (incf count))))
    count))

(defun count-sides (map)
  (let ((count 0))
    (dotimes (k (third (array-dimensions map)) count)
      (dotimes (j (second (array-dimensions map)))
	(dotimes (i (first (array-dimensions map)))
	  (incf count (check-sides i j k map)))))))

(defun find-outside (map)
  (let ((out (make-array (array-dimensions map) :initial-element nil)))
    (setf (aref out 0 0 0) t)
    (do ((changed 1))
	((zerop changed) out)
      (setf changed 0)
      (dotimes (k (third (array-dimensions map)))
	(dotimes (j (second (array-dimensions map)))
	  (dotimes (i (first (array-dimensions map)))
	    (when (equal (aref out i j k) t)
	      (unless (zerop i)
		(unless (equal (aref out (- i 1) j k) t)
		  (unless (equal (aref map (- i 1) j k) t)
		    (setf (aref out (- i 1) j k) t)
		    (incf changed))))
	      (unless (equal i (- (first (array-dimensions map)) 1))
		(unless (equal (aref out (+ i 1) j k) t)
		  (unless (equal (aref map (+ i 1) j k) t)
		    (setf (aref out (+ i 1) j k) t)
		    (incf changed))))
	      (unless (zerop j)
		(unless (equal (aref out i (- j 1) k) t)
		  (unless (equal (aref map i (- j 1) k) t)
		    (setf (aref out i (- j 1) k) t)
		    (incf changed))))
	      (unless (equal j (- (second (array-dimensions map)) 1))
		(unless (equal (aref out i (+ j 1) k) t)
		  (unless (equal (aref map i (+ j 1) k) t)
		    (setf (aref out i (+ j 1) k) t)
		    (incf changed))))
	      (unless (zerop k)
		(unless (equal (aref out i j (- k 1)) t)
		  (unless (equal (aref map i j (- k 1)) t)
		    (setf (aref out i j (- k 1)) t)
		    (incf changed))))
	      (unless (equal k (- (third (array-dimensions map)) 1))
		(unless (equal (aref out i j (+ k 1)) t)
		  (unless (equal (aref map i j (+ k 1)) t)
		    (setf (aref out i j (+ k 1)) t)
		    (incf changed)))))))))))

(defun close-holes (map out)
  (dotimes (k (third (array-dimensions out)) map)
    (dotimes (j (second (array-dimensions out)))
      (dotimes (i (first (array-dimensions out)))
	(if (null (aref out i j k))
	    (setf (aref map i j k) t))))))

(defun count-outside (map &aux out)
  (setf out (find-outside map))
  (close-holes map out)
  (count-sides map))

(count-sides (setup "input.txt"))
(count-outside (setup "input.txt"))

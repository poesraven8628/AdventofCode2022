(ql:quickload "str")

(defun get-all-input (filename)
  (with-open-file (stream filename)
    (loop for line = (read-line stream nil)
          while line
          collect line)))

(defun make-grid (s)
  (do ((n (length s))
       (a (make-array (list (length (first s)) (length s)) :initial-element 0))
       (row (pop s) (pop s))
       (j 0 (+ j 1)))
      ((equal j n) a)
    (dotimes (i (length row))
      (setf (aref a j i) (digit-char-p (aref row i))))))

(defun visibility (a)
  (do ((n (first (array-dimensions a)))
       (s1 nil)
       (s2 nil)
       (s3 nil)
       (s4 nil)
       (v (make-array (array-dimensions a) :initial-element 'Y))
       (j 0 (+ j 1)))
      ((equal j n) v)
    (dotimes (i (second (array-dimensions a)))
      (if (or (equal i 0)
	      (equal j 0)
	      (equal i (- (second (array-dimensions a)) 1))
	      (equal j (- (first (array-dimensions a)) 1)))
	  (setf (aref v j i) 'Y)
	  (progn
	    (setf s1 nil)
	    (setf s2 nil)
	    (setf s3 nil)
	    (setf s4 nil)
	    (dotimes (chn j)
	      (if (>= (aref a chn i) (aref a j i))
		  (setf s1 t)))
	    (dotimes (chn i)
	      (if (>= (aref a j chn) (aref a j i))
		  (setf s2 t)))
	    (do ((chn (+ j 1) (+ 1 chn)))
		((equal chn n))
	      (if (>= (aref a chn i) (aref a j i))
		  (setf s3 t)))
	    (do ((chn (+ i 1) (+ 1 chn)))
		((equal chn (second (array-dimensions a))))
	      (if (>= (aref a j chn) (aref a j i))
		  (setf s4 t)))
	    (if (and s1 s2 s3 s4)
		(setf (aref v j i) 'N)
		(setf (aref v j i) 'Y)))))))

(defun count-seen (a)
  (let ((count 0))
    (dotimes (j (first (array-dimensions a)) count)
      (dotimes (i (second (array-dimensions a)))
	(if (equal (aref a j i) 'Y)
	    (incf count))))))

(defun scenic (a)
  (do ((n (first (array-dimensions a)))
       (s1 0)
       (s2 0)
       (s3 0)
       (s4 0)
       (v (make-array (array-dimensions a) :initial-element 0))
       (j 0 (+ j 1)))
      ((equal j n) v)
    (dotimes (i (second (array-dimensions a)))
      (setf s1 0)
      (setf s2 0)
      (setf s3 0)
      (setf s4 0)
      (unless (or (equal i 0)
	      (equal j 0)
	      (equal i (- (second (array-dimensions a)) 1))
	      (equal j (- (first (array-dimensions a)) 1)))
	(do ((chn (- j 1) (- chn 1)))
	    ((< chn 0))
	  (incf s1)
	  (if (>= (aref a chn i) (aref a j i)) (return)))
	(do ((chn (- i 1) (- chn 1)))
	    ((< chn 0))
	  (incf s2)
	  (if (>= (aref a j chn) (aref a j i)) (return)))
	(do ((chn (+ j 1) (+ chn 1)))
	    ((equal chn n))
	  (incf s3)
	  (if (>= (aref a chn i) (aref a j i)) (return)))
	(do ((chn (+ i 1) (+ chn 1)))
	    ((equal chn (second (array-dimensions a))))
	  (incf s4)
	  (if (>= (aref a j chn) (aref a j i)) (return))))
      (setf (aref v j i) (* s1 s2 s3 s4)))))
	
(defun find-scenic (a)
  (let ((highest 0))
    (dotimes (j (first (array-dimensions a)) highest)
      (dotimes (i (second (array-dimensions a)))
	(if (> (aref a j i) highest)
	    (setf highest (aref a j i)))))))

(count-seen (visibility (make-grid (get-all-input "input.txt"))))
(find-scenic (scenic (make-grid (get-all-input "input.txt"))))

(ql:quickload "str")

(defun get-all-input (input)
  (with-open-file (stream input)
    (loop for line = (read-line stream nil)
          while line
          collect line)))

(defun parse-ops (s)
  (mapcar #'(lambda (e) (str:split " " e)) s))

(defun process (s)
  (do* ((ret nil)
	(clock 1 (+ clock 1))
	(count 1)
	(adder nil)
	(toadd 0)
	(place s)
	(line (first place)))
       ((null line) (reverse ret))
    (push count ret)
    (cond ((equal adder t)
	   (incf count toadd)
	   (setf toadd 0)
	   (setf adder nil)
	   (setf place (rest place))
	   (setf line (first place)))
	  ((equal (first line) "addx")
	   (setf toadd (parse-integer (second line)))
	   (setf adder t))
	  ((equal (first line) "noop")
	   (setf place (rest place))
	   (setf line (first place))))))

(defun six-vals (a)
  (let ((b nil))
    (push (* 20 (nth 19 a)) b)
    (push (* 60 (nth 59 a)) b)
    (push (* 100 (nth 99 a)) b)
    (push (* 140 (nth 139 a)) b)
    (push (* 180 (nth 179 a)) b)
    (push (* 220 (nth 219 a)) b)
    (reduce #'+ b)))

(defun draw-pixel? (time pos)
  (let ((coord (mod time 40)))
    (if (or (equal pos (- coord 1))
	    (equal pos coord)
	    (equal pos (+ coord 1)))
	t
	nil)))

(defun show-screen (a)
  (format t "~&~%")
  (dotimes (i 40)
    (format t "*"))
  (format t "~&~%")
  (dotimes (i (length a))
    (format t "~A" (aref a i))
    (if (and (not (zerop i)) (zerop (mod (+ i 1) 40)))
	(format t "~%")))
  (format t "~&~%")
  (dotimes (i 40)
    (format t "*"))
  (format t "~&~%")
  (finish-output))

(defun make-screen (s)
  (make-array (length s) :initial-element #\.))

(defun draw-screen (s)
  (let ((screen (make-screen s))
	(i 0))
    (dolist (pos s screen)
      (if (draw-pixel? i pos)
	  (setf (aref screen i) #\#)
	  (setf (aref screen i) #\.))
      (incf i))))

(six-vals (process (parse-ops (get-all-input "input.txt"))))
(show-screen (draw-screen (process (parse-ops (get-all-input "input.txt")))))

(ql:quickload "str")

(defun get-all-input (input)
  (with-open-file (stream input)
    (loop for line = (read-line stream nil)
          while line
          collect line)))

(defun parse-input (input &aux ret tmp)
  (dolist (e input (nreverse ret))
    (setf tmp (str:words e))
    (if (equal 2 (length tmp))
	(push (list (first (str:split ":" (first tmp))) (parse-integer (second tmp))) ret)
	(push (list (first (str:split ":" (first tmp))) (second tmp) (third tmp) (fourth tmp)) ret))))

(defstruct monkey
  (name nil)
  (op nil)
  (value 0)
  (alpha nil)
  (beta nil))

(defun create-monkeys (input &aux ret tmp)
  (dolist (e input (nreverse ret))
    (setf tmp (make-monkey :name (first e)))
    (if (equal 2 (length e))
	(setf (monkey-value tmp) (second e))
	(progn
	  (setf (monkey-op tmp) (third e))
	  (setf (monkey-alpha tmp) (second e))
	  (setf (monkey-beta tmp) (fourth e))))
    (push tmp ret)))

(defun find-monkey (name lst)
  (dotimes (i (length lst))
    (if (equal (monkey-name (nth i lst)) name)
	(return-from find-monkey i))))

(defun math-monkey (monkey)
  (cond ((equal (monkey-op monkey) "+") #'+)
	((equal (monkey-op monkey) "-") #'-)
	((equal (monkey-op monkey) "*") #'*)
	((equal (monkey-op monkey) "/") #'/)))

(defun math-op (op)
  (cond ((equal op "+") #'+)
	((equal op "-") #'-)
	((equal op "*") #'*)
	((equal op "/") #'/)))

(defun math-un-op (op)
  (cond ((equal op "+") #'-)
	((equal op "-") #'+)
	((equal op "*") #'/)
	((equal op "/") #'*)))

(defun do-monkey (monkey lst)
  (cond ((null (monkey-op monkey)) (monkey-value monkey))
	(t (funcall (math-monkey monkey)
		    (do-monkey (nth (find-monkey (monkey-alpha monkey) lst) lst) lst)
		    (do-monkey (nth (find-monkey (monkey-beta monkey) lst) lst) lst)))))

(defun find-formula (monkey lst)
  (cond ((equal (monkey-name monkey) "humn") "humn")
	((null (monkey-op monkey)) (monkey-value monkey))
	(t (list (monkey-op monkey)
	   (find-formula (nth (find-monkey (monkey-alpha monkey) lst) lst) lst)
	   (find-formula (nth (find-monkey (monkey-beta monkey) lst) lst) lst)))))

(defun do-formula (form)
  (cond ((numberp form) form)
	(t (funcall (math-op (first form))
		    (do-formula (second form))
		    (do-formula (third form))))))

(defun check-for-humn (form) 
  (cond ((equal form "humn") t)
	((numberp form) nil)
	(t (or (check-for-humn (second form))
	       (check-for-humn (third form))))))

(defun solve-for-humn (form val)
  (cond ((numberp form) form)
	(t (cond ((equal (second form) "humn")
		  (funcall (math-un-op (first form))
			   val (do-formula (third form))))
		 ((equal (third form) "humn")
		  (cond ((equal (first form) "+")
			 (- val (do-formula (second form))))
			((equal (first form) "-")
			 (- (do-formula (second form)) val))
			((equal (first form) "*")
			 (/ val (do-formula (second form))))
			((equal (first form) "/")
			 (/ (do-formula (second form)) val))))
		 ((check-for-humn (second form))
		  (solve-for-humn (second form)
				  (funcall (math-un-op (first form))
					   val (do-formula (third form)))))
		 (t (solve-for-humn (third form)
				    (cond ((equal (first form) "+")
					   (- val (do-formula (second form))))
					  ((equal (first form) "-")
					   (- (do-formula (second form)) val))
					  ((equal (first form) "*")
					   (/ val (do-formula (second form))))
					  ((equal (first form) "/")
					   (/ (do-formula (second form)) val)))))))))
		    
(defun get-root (input &aux lst)
  (setf lst (create-monkeys (parse-input (get-all-input input))))
  (do-monkey (nth (find-monkey "root" lst) lst) lst))

(defun get-humn (input &aux lst alpha beta alpha-val beta-val alpha-form beta-form)
  (setf lst (create-monkeys (parse-input (get-all-input input))))
  (setf alpha (find-monkey (monkey-alpha (nth (find-monkey "root" lst) lst)) lst))
  (setf beta (find-monkey (monkey-beta (nth (find-monkey "root" lst) lst)) lst))
  (setf alpha-val (do-monkey (nth alpha lst) lst))
  (setf beta-val (do-monkey (nth beta lst) lst))
  (setf alpha-form (find-formula (nth alpha lst) lst))
  (setf beta-form (find-formula (nth beta lst) lst))
  (solve-for-humn alpha-form alpha-val)
  (if (check-for-humn alpha-form)
      (solve-for-humn alpha-form beta-val)
      (solve-for-humn beta-form alpha-val)))

(get-root "input.txt")
(get-humn "input.txt")

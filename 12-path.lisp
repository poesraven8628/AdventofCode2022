(defun get-all-input (input)
  (with-open-file (stream input)
    (loop for line = (read-line stream nil)
          while line
          collect line)))

(defun make-map (s)
  (let ((map nil)
	(y (length s))
	(x (length (first s))))
    (setf map (make-array (list y x) :initial-element #\a))
    (dotimes (j (length s)  map)
      (dotimes (i (length (first s)))
	(setf (aref map j i) (aref (nth j s) i))))))

(defconstant MAX_DISTANCE 2147483000)

(defun height (x y m)
  (let ((alpha "abcdefghijklmnopqrstuvwxyz")
	(letter (aref m y x)))
    (cond ((equal letter #\S) 0)
	  ((equal letter #\E) 25)
	  (t (position letter alpha)))))

(defun find-start-end (m)
  (labels ((find-one (sym m)
	     (dotimes (j (first (array-dimensions m)))
	       (dotimes (i (second (array-dimensions m)))
		 (if (equal sym (aref m j i))
		     (return-from find-one (values i j)))))))
    (multiple-value-bind (start-x start-y) (find-one #\S m)
      (multiple-value-bind (end-x end-y) (find-one #\E m)
	(list start-x start-y end-x end-y)))))

(defun find-lowest (dm vm)
  (let ((x nil)
	(y nil)
	(dist MAX_DISTANCE))
    (dotimes (j (first (array-dimensions dm)))
      (dotimes (i (second (array-dimensions dm)))
	(when (and (not (aref vm j i))
		   (> dist (aref dm j i)))
	  (setf dist (aref dm j i))
	  (setf x i)
	  (setf y j))))
    (list x y)))

(defun check-range (x y m)
  (if (< x 0) (return-from check-range nil))
  (if (< y 0) (return-from check-range nil))
  (if (>= x (second (array-dimensions m))) (return-from check-range nil))
  (if (>= y (first (array-dimensions m))) (return-from check-range nil))
  t)

(defun can-enter (sx sy ex ey m)
  (if (not (check-range sx sy m)) (return-from can-enter nil))
  (if (not (check-range ex ey m)) (return-from can-enter nil))
  (if (> (- (height ex ey m) (height sx sy m)) 1) (return-from can-enter nil))
  t)

(defun can-explore (sx sy ex ey m v)
  (if (not (can-enter sx sy ex ey m)) (return-from can-explore nil))
  (not (aref v ey ex)))

(defun make-dijkstra-map (m &optional nsx nsy)
  (let* ((dm (make-array (array-dimensions m) :initial-element MAX_DISTANCE))
	 (vm (make-array (array-dimensions m) :initial-element nil))
	 (loc (find-start-end m))
	 (start-x (first loc))
	 (start-y (second loc))
	 (end-x (third loc))
	 (end-y (fourth loc)))
    (when (not (null nsx))
      (setf start-x nsx)
      (setf start-y nsy))
    (setf (aref dm start-y start-x) 0)
    (setf (aref vm start-y start-x) t)
    (do ((x start-x)
	 (y start-y)
	 (dist 0)
	 (nx 0)
	 (ny 0)
	 (times 0 (+ times 1)))
	((and (equal x end-x)
	      (equal y end-y)) dm)
      (setf dist (aref dm y x))
      (setf nx (+ x 1))
      (setf ny y)
      (when (can-enter x y nx ny m)
	(if (< (+ 1 dist) (aref dm ny nx))
	    (setf (aref dm ny nx) (+ 1 dist))))
      (setf nx (- x 1))
      (setf ny y)
      (when (can-enter x y nx ny m)
	(if (< (+ 1 dist) (aref dm ny nx))
	    (setf (aref dm ny nx) (+ 1 dist))))
      (setf nx x)
      (setf ny (+ y 1))
      (when (can-enter x y nx ny m)
	(if (< (+ 1 dist) (aref dm ny nx))
	    (setf (aref dm ny nx) (+ 1 dist))))
      (setf nx x)
      (setf ny (- y 1))
      (when (can-enter x y nx ny m)
	(if (< (+ 1 dist) (aref dm ny nx))
	    (setf (aref dm ny nx) (+ 1 dist))))
      (setf loc (find-lowest dm vm))
      (setf x (first loc))
      (setf y (second loc))
      (if (or (null x)
	      (null y))
	  (return-from make-dijkstra-map (make-array (array-dimensions m) :initial-element MAX_DISTANCE)))
      (setf (aref vm y x) t))))

(defun get-distance (m)
  (let* ((loc (find-start-end m))
	 (end-x (third loc))
	 (end-y (fourth loc))
	 (dm (make-dijkstra-map m)))
    (aref dm end-y end-x)))

(defun get-all-hikes (m)
  (let* ((loc (find-start-end m))
	 (start-x (first loc))
	 (start-y (second loc))
	 (end-x (third loc))
	 (end-y (fourth loc))
	 (pathlen)
	 (shortlen)
	 (dm (make-dijkstra-map m start-x start-y)))
    (setf pathlen (aref dm end-y end-x))
    (setf shortlen pathlen)
    (dotimes (j (first (array-dimensions m)))
      (dotimes (i (second (array-dimensions m)))
	(when (equal (aref m j i) #\a)
	  (setf pathlen (aref (make-dijkstra-map m i j) end-y end-x))
	  (if (< pathlen shortlen)
	      (setf shortlen pathlen)))))
    shortlen))
    

(get-distance (make-map (get-all-input "input.txt")))
(get-all-hikes (make-map (get-all-input "input.txt")))

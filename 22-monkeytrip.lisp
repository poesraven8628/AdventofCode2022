(ql:quickload "str")
(ql:quickload "cl-ppcre")

(defun get-all-input (input)
  (with-open-file (stream input)
    (loop for line = (read-line stream nil)
          while line
          collect line)))

(defun parse-input (input &aux width height lmap map dir)
  (dolist (e input)
    (cond ((equal e ""))
	  ((or (equal (aref e 0) #\Space)
	       (equal (aref e 0) #\.)
	       (equal (aref e 0) #\#))
	   (push e lmap))
	  (t (push e dir))))
  (setf lmap (nreverse lmap))
  (setf width 0)
  (dolist (e lmap)
    (if (> (length e) width)
	(setf width (length e))))
  (incf width 2)
  (setf height (length lmap))
  (incf height 2)
  (setf map (make-array (list width height) :initial-element #\Space))
  (dotimes (j (length lmap))
    (dotimes (i (length (nth j lmap)))
      (setf (aref map (+ i 1) (+ j 1)) (aref (nth j lmap) i))))
  (setf dir (cl-ppcre:split "([LR])" (first dir) :with-registers-p t))
  (do ((i 1 (+ i 1)))
      ((equal (aref map i 1) #\.)
       (list i map dir))))

(defun print-map (map)
  (dotimes (j (second (array-dimensions map)))
    (format t "~&")
    (dotimes (i (first (array-dimensions map)))
      (format t "~A" (aref map i j))))
  (finish-output))

(defun face-turn (old turn)
  (cond ((equal turn "R")
	 (case old
	   (right 'down)
	   (down 'left)
	   (left 'up)
	   (up 'right)))
	((equal turn "L")
	 (case old
	   (right 'up)
	   (down 'right)
	   (left 'down)
	   (up 'left)))))

(defun face-value (facing)
  (case facing
    (right 0)
    (down 1)
    (left 2)
    (up 3)))

(defun warp-move (ox oy x y facing map)
  (cond ((equal facing 'right)
	 (do ((i 0 (+ i 1)))
	     ((not (equal (aref map i y) #\Space))
	      (list i y facing))))
	((equal facing 'left)
	 (do ((i (- (first (array-dimensions map)) 1) (- i 1)))
	     ((not (equal (aref map i y) #\Space))
	      (list i y facing))))
	((equal facing 'down)
	 (do ((i 0 (+ i 1)))
	     ((not (equal (aref map x i) #\Space))
	      (list x i facing))))
	((equal facing 'up)
	 (do ((i (- (second (array-dimensions map)) 1) (- i 1)))
	     ((not (equal (aref map x i) #\Space))
	      (list x i facing))))))

(defun find-input-face (x y)
  (cond ((and (< y 51)
	      (>= x 101)) 'a)
	((and (< y 51)
	      (< x 101)
	      (>= x 51)) 'b)
	((and (>= y 51)
	      (< y 101)
	      (>= x 51)
	      (< x 101)) 'c)
	((and (>= y 101)
	      (< y 151)
	      (>= x 51)
	      (< x 101)) 'd)
	((and (>= y 101)
	      (< y 151)
	      (< x 51)) 'e)
	((and (>= y 151)
	      (< x 51)) 'f)))

(defun input-cube-warp (ox oy x y facing map)
  (let ((cube-face (find-input-face ox oy)))
    (cond ((and (equal cube-face 'a)
		(equal facing 'up))
	   (list (- x 100) 200 facing))
	  ((and (equal cube-face 'a)
		(equal facing 'right))
	   (list 100 (- 151 y) 'left))
	  ((and (equal cube-face 'a)
		(equal facing 'down))
	   (list 100 (- x 50) 'left))
	  ((and (equal cube-face 'b)
		(equal facing 'up))
	   (list 1 (+ x 100) 'right))
	  ((and (equal cube-face 'b)
		(equal facing 'left))
	   (list 1 (- 151 y) 'right))
	  ((and (equal cube-face 'c)
		(equal facing 'right))
	   (list (+ 50 y) 50 'up))
	  ((and (equal cube-face 'c)
		(equal facing 'left))
	   (list (- y 50) 101 'down))
	  ((and (equal cube-face 'd)
		(equal facing 'right))
	   (list 150 (- 151 y) 'left))
	  ((and (equal cube-face 'd)
		(equal facing 'down))
	   (list 50 (+ 100 x) 'left))
	  ((and (equal cube-face 'e)
		(equal facing 'up))
	   (list 51 (+ 50 x) 'right))
	  ((and (equal cube-face 'e)
		(equal facing 'left))
	   (list 51 (- 151 y) 'right))
	  ((and (equal cube-face 'f)
		(equal facing 'right))
	   (list (- y 100) 150 'up))
	  ((and (equal cube-face 'f)
		(equal facing 'left))
	   (list (- y 100) 1 'down))
	  ((and (equal cube-face 'f)
		(equal facing 'down))
	   (list (+ 100 x) 1 'down)))))

(defun do-move (n x y facing warp map)
  (let ((x-mod 0)
	(y-mod 0)
	(tmp nil))
    (case facing
      (right (setf x-mod 1))
      (down (setf y-mod 1))
      (left (setf x-mod -1))
      (up (setf y-mod -1)))
    (dotimes (i n (list x y facing))
      (cond ((equal (aref map (+ x x-mod) (+ y y-mod)) #\.)
	     (incf x x-mod) 
	     (incf y y-mod))
	    ((equal (aref map (+ x x-mod) (+ y y-mod)) #\#))
	    ((equal (aref map (+ x x-mod) (+ y y-mod)) #\Space)
	     (setf tmp (funcall warp  x y (+ x x-mod) (+ y y-mod) facing map))
	     (when (equal (aref map (first tmp) (second tmp)) #\.)
	       (setf x (first tmp))
	       (setf y (second tmp))
	       (setf facing (third tmp))
	       (setf x-mod 0)
	       (setf y-mod 0)
	       (case facing
		 (right (setf x-mod 1))
		 (down (setf y-mod 1))
		 (left (setf x-mod -1))
		 (up (setf y-mod -1)))))))))

(defun monkey-path (warp input)
  (let ((x (first input))
	(y 1)
	(tmp nil)
	(facing 'right)
	(map (second input))
	(dir (third input)))
    (dolist (d dir)
      (cond ((equal d "R") (setf facing (face-turn facing d)))
	    ((equal d "L") (setf facing (face-turn facing d)))
	    (t (setf d (parse-integer d))
	       (setf tmp (do-move d x y facing warp map))
	       (setf x (first tmp))
	       (setf y (second tmp))
	       (setf facing (third tmp)))))
    (+ (* 1000 y) (* 4 x) (face-value facing))))

(monkey-path #'warp-move (parse-input (get-all-input "input.txt")))
(monkey-path #'input-cube-warp (parse-input (get-all-input "input.txt")))
